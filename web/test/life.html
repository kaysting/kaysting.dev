<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life</title>
</head>
<body>
    <div class="col">
        <canvas></canvas>
        <div class="row">
            <button id="play" class="btn">Play</button>
            <button id="pause" class="btn" disabled>Pause</button>
            <button id="step" class="btn">Step</button>
            <button id="clear" class="btn">Clear</button>
            <label>Cell size:</label>
            <input type="number" value="25" min="1" max="100" step="1" id="gridSize">
            <label>Step interval ms:</label>
            <input type="number" value="500" min="1" max="10000" step="1" id="stepInterval">
        </div>
    </div>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black;
            color: white;
            font-family: sans-serif;
        }
        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 0px 10px;
            height: 40px;
        }
        .col {
            display: flex;
            flex-direction: column;
        }
    </style>
    <script>
        let gridSize = 25;
        let stepInterval = 100;
        const canvas = document.querySelector('canvas');
        const context = canvas.getContext('2d');
        const btnPlay = document.querySelector('#play');
        const btnPause = document.querySelector('#pause');
        const btnStep = document.querySelector('#step');
        const btnClear = document.querySelector('#clear');
        const inputGridSize = document.querySelector('#gridSize');
        const inputStepInterval = document.querySelector('#stepInterval');
        const startTime = Date.now();
        let totalFrames = 0;
        let diagnostic = '';
        let gridWidth = 0;
        let gridHeight = 0;
        let grid = [];
        let lastStep = Date.now();
        let isPlaying = false;
        const step = () => {
            const newGrid = [];
            for (let x = 0; x < gridWidth; x++) {
                newGrid[x] = [];
                for (let y = 0; y < gridHeight; y++) {
                    const cell = grid[x][y];
                    const neighbors = [
                        grid[x - 1]?.[y - 1],
                        grid[x]?.[y - 1],
                        grid[x + 1]?.[y - 1],
                        grid[x - 1]?.[y],
                        grid[x + 1]?.[y],
                        grid[x - 1]?.[y + 1],
                        grid[x]?.[y + 1],
                        grid[x + 1]?.[y + 1],
                    ].filter(Boolean).length;
                    if (cell) {
                        if (neighbors < 2 || neighbors > 3)
                            newGrid[x][y] = 0;
                        else
                            newGrid[x][y] = 1;
                    } else {
                        if (neighbors === 3)
                            newGrid[x][y] = 1;
                        else
                            newGrid[x][y] = 0;
                    }
                }
            }
            grid = newGrid;
        };
        btnPlay.addEventListener('click', () => {
            isPlaying = true;
            btnPlay.disabled = true;
            btnPause.disabled = false;
            btnStep.disabled = true;
        });
        btnPause.addEventListener('click', () => {
            isPlaying = false;
            btnPlay.disabled = false;
            btnPause.disabled = true;
            btnStep.disabled = false;
        });
        btnStep.addEventListener('click', step);
        btnClear.addEventListener('click', () => {
            grid = [];
            btnPause.dispatchEvent(new Event('click'));
        });
        inputGridSize.addEventListener('change', () => {
            gridSize = Number(inputGridSize.value);
        });
        inputStepInterval.addEventListener('change', () => {
            stepInterval = Number(inputStepInterval.value);
        });
        const update = () => {
            // Resize canvas
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight-40;
            gridWidth = Math.floor(canvas.width / gridSize);
            gridHeight = Math.floor(canvas.height / gridSize);
            // Update cells
            if (grid.length !== gridWidth || grid[0].length !== gridHeight) {
                grid = [];
                for (let x = 0; x < gridWidth; x++) {
                    grid[x] = [];
                    for (let y = 0; y < gridHeight; y++) {
                        grid[x][y] = 0;
                    }
                }
            }
            // Step if playing
            if (isPlaying && (Date.now() - lastStep) > stepInterval) {
                step();
                lastStep = Date.now();
            }
            // Draw background
            context.fillStyle = 'black';
            context.fillRect(0, 0, canvas.width, canvas.height);
            // Draw active cells
            context.fillStyle = 'white';
            for (let x = 0; x < gridWidth; x++) {
                for (let y = 0; y < gridHeight; y++) {
                    const cell = grid[x][y];
                    if (cell)
                        context.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                }
            }
            // Draw grid
            context.strokeStyle = '#77777777';
            context.lineWidth = 1;
            context.beginPath();
            for (let x = 0; x <= gridWidth; x++) {
                context.moveTo(x * gridSize, 0);
                context.lineTo(x * gridSize, gridSize * gridHeight);
            }
            for (let y = 0; y <= gridHeight; y++) {
                context.moveTo(0, y * gridSize);
                context.lineTo(gridSize * gridWidth, y * gridSize);
            }
            context.stroke();
            // Finish
            totalFrames++;
            diagnostic = `Runtime: ${Date.now() - startTime}ms  Frames: ${totalFrames}  FPS: ${Math.round(totalFrames / ((Date.now() - startTime) / 1000))}`;
            requestAnimationFrame(update);
        };
        update();
        let changedCells = [];
        canvas.addEventListener('mouseup', event => {
            const x = Math.floor(event.clientX / gridSize);
            const y = Math.floor(event.clientY / gridSize);
            if (!changedCells.includes(x + ',' + y))
                grid[x][y] = grid[x][y] ? 0 : 1;
            changedCells = [];
        });
        canvas.addEventListener('mousemove', event => {
            const x = Math.floor(event.clientX / gridSize);
            const y = Math.floor(event.clientY / gridSize);
            if (!event.buttons) return;
            if (event.buttons === 1)
                grid[x][y] = 1;
            else if (event.buttons === 2)
                grid[x][y] = 0;
            changedCells.push(x + ',' + y);
        });
    </script>
</body>
</html>